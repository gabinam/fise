# FISE - Fast Internet Secure Extensible

[![npm version](https://img.shields.io/npm/v/fise.svg)](https://www.npmjs.com/package/fise)
[![npm downloads](https://img.shields.io/npm/dm/fise.svg)](https://www.npmjs.com/package/fise)
[![license](https://img.shields.io/github/license/anbkit/fise)](./LICENSE)
[![TypeScript](https://img.shields.io/badge/TypeScript-Ready-blue.svg)](https://www.typescriptlang.org/)

---

## ğŸ”¥ What is FISE?

**FISE is a keyless, rule-based, high-performance envelope for protecting API responses and frontend data.**

It is not a replacement for AES, TLS, or authentication.  
FISE is designed for *web response protection*, where traditional crypto is too heavy â€” or exposes static keys in the frontend.

FISE focuses on:

- high-speed transformations
- rule-based semantic obfuscation
- infinite customization
- zero shared pattern between apps

---

## âš¡ Performance Benchmark (Node 20, M1)

| Method                    | Avg Time (per op) |
| ------------------------- | ----------------- |
| **FISE encrypt**          | ~0.02â€“0.04 ms     |
| **FISE decrypt**          | ~0.01â€“0.02 ms     |
| AES (crypto-js) decrypt   | ~0.4â€“0.9 ms       |
| WebCrypto AES-GCM decrypt | ~0.15â€“0.35 ms     |

### Why is FISE so fast?

- No heavy crypto unless you plug in your own cipher  
- Pure string operations  
- No hashing, PBKDF, or expensive key derivation  
- Runs thousands of ops per frame in frontend  
- Perfect for high-frequency API usage  

**FISE is optimized for web response protection, not heavyweight cryptography.**

---

## ğŸ” The True Strength of FISE: Infinite Customization, Zero Standard Format

FISE does **not** rely on a single encryption scheme.  
Its strength comes from **unpredictability** and **per-application uniqueness**.

Each implementation can be entirely different:

- no fixed envelope format  
- no universal salt position  
- no predictable metadata  
- no shared offset rule  
- no constant cipher  
- no standard scanning method  
- no global structure  

### Every website/app becomes its **own encryption dialect**.

You can customize:

- salt generation  
- salt placement (front, end, interleave, fragmented)  
- timestamp-based entropy  
- metadata encoding (base36, base62, emoji, hex, XOR, zero-width)  
- metadata size  
- offset rules  
- scanning patterns (charCodeAt, primes, XOR signature)  
- optional ciphers (AES, XOR, hybrid)  
- envelope assembly strategy  
- decoy/noise injection  

The customization space is **effectively infinite** â†’ two apps almost never share the same pipeline.

### This yields powerful security properties:

- âŒ No universal decoder can ever exist  
- ğŸ”’ Reverse-engineering one FISE target does **not** help decode another  
- ğŸ§© No fixed patterns  
- ğŸ”„ Rules can rotate or regenerate instantly  
- ğŸ­ Security comes from diversity, not secrecy  

> **FISE turns every app into a unique encryption language.**

---

# ğŸŒ± The Future Direction of FISE (Rule Ecosystem)

FISE is not just a library â€” it is evolving into a **platform** for creating, sharing, and generating rule-based pipelines.

## ğŸ§© Community Rule Ecosystem (Planned)

Developers will be able to publish:

- lightweight rule-sets  
- high-entropy rule-sets  
- emoji-channel metadata rules  
- zero-width metadata encoders  
- timestamp-derived offset models  
- AES/XOR hybrid pipelines  
- WASM-optimized rules  

Each application can choose or combine multiple rule packs â†’ accelerating diversity.

This eliminates the possibility of universal attacks across multiple apps.

---

## ğŸ¨ Rule Builder (Upcoming)

A **visual rule builder** will allow developers to design custom pipelines without security expertise:

- choose salt generator  
- build metadata channels  
- define offsets  
- optionally add cipher stages  
- add rotation sets  
- preview final envelope shape  

Rule Builder will generate:

- `encode()` server function  
- `decode()` client function  
- TypeScript typings  
- tests  
- performance hints  
- HMAC validation helpers  

Anyone can build a full FISE pipeline â€” no crypto knowledge required.

---

## ğŸ¤– AI-Generated Custom Rules

Because FISE pipelines have infinite variability, rule-sets can be **generated by AI** safely:

- describe your requirements (speed, entropy, CDN safety, rotation frequency)  
- AI outputs a unique rule-set  
- no two AI-generated pipelines need to be alike  

FISE becomes stronger as the ecosystem grows.

---

# ğŸŒ Community Rule Index (Future)

We plan to maintain a public rule index:

- curated well-tested rules  
- experimental research rules  
- normalization-resistant channels  
- multi-layer offset packs  
- WASM fast-path pipelines  

Each rule pack will include:

- encode/decode implementation  
- documentation  
- performance metrics  
- CDN/Unicode normalization safety  
- tests  
- security considerations  

---

## ğŸ“¦ Installation

```bash
npm install fise
```

---

## ğŸš€ Basic Usage

```ts
import { encryptFise, decryptFise } from "fise";

const encrypted = encryptFise("Hello, world!");
const decrypted = decryptFise(encrypted);

console.log(encrypted);
console.log(decrypted); // "Hello, world!"
```

---

## ğŸ§© Architecture Overview

A FISE transformation pipeline includes:

1. Salt generation  
2. Metadata encoding  
3. Optional cipher layer  
4. Offset calculation  
5. Envelope assembly  
6. Custom insertion rules  
7. Final packed string  

Every stage is customizable.

---

## ğŸ“š Documentation

- `docs/RULES.md` â€” rule customization  
- `docs/SPEC.md` â€” transformation spec  
- `docs/PERFORMANCE.md` â€” benchmarks  
- `docs/SECURITY.md` â€” security model  
- `docs/WHITEPAPER.md` â€” full whitepaper (v1.0)

---

## ğŸ›¡ Security Philosophy

FISE is *not* AES.  
FISE is *not* a replacement for secret-grade encryption.  

It is a **semantic protection layer** built for:

- anti-scraping  
- data obfuscation  
- protecting curated datasets  
- raising attacker cost  
- avoiding universal decoders  
- preventing naive dataset cloning  

---

## ğŸ¤ Contributing

We welcome:

- rule designs  
- offset strategies  
- scanner patterns  
- cipher extensions  
- performance optimizations  
- ecosystem proposals  

See `CONTRIBUTING.md`.

---

## ğŸ“„ License

MIT Â© An Nguyen
